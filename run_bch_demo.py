# run_bch_demo.py
# ============================================================
#  分块 BCH McEliece 变体 —— 快速演示脚本（Demo）
# ============================================================
#
# 【本文件在整个项目中的定位】
# ------------------------------------------------------------
# 这是一个“一键可运行”的最小演示脚本，主要用于：
#
# 1) 快速验证系统功能正确性：
#    - KeyGen 是否能正常生成密钥
#    - Encrypt / Decrypt 是否能正确配合
#    - 在合法错误模型下是否能成功解密
#
# 2) 助教快速检查：
#    - 不需要跑 benchmark
#    - 不需要 MATLAB
#    - 直接运行即可看到完整流程输出
#
# ⚠ 注意：
#    - 本文件【不做】重复实验
#    - 本文件【不统计】均值、标准差
#    - 本文件【不生成 CSV】
#
# 所有“实验数据”和“画图”都交给：
#    - run_benchmark.py
#    - MATLAB main.m
#
# ============================================================
# 运行方式（在 code/ 目录下）：
# ------------------------------------------------------------
#   python run_bch_demo.py
# ============================================================


# ===================== 标准库导入 ============================
import time
import random


# ===================== 项目内部模块导入 ======================
# 说明：
# - run_bch_demo.py 位于 code/ 根目录
# - bch_mceliece/ 是同级目录（Python 包）
# - 只要 bch_mceliece/__init__.py 存在，下面导入就是稳定的

from .bch_mceliece.keygen_bch import keygen
from .bch_mceliece.encrypt_bch import encrypt
from .bch_mceliece.decrypt_bch import decrypt


# ============================================================
# 工具函数：生成随机明文
# ============================================================

def _rand_bits(length: int):
    """
    生成长度为 length 的随机二进制向量。

    用途：
    - 模拟随机明文 m
    - 每一位独立取 0 或 1

    之所以写成单独函数，而不是 inline：
    - 便于阅读主流程
    - 便于后续如果你想换成固定明文/全 0 明文
    """
    return [random.randint(0, 1) for _ in range(length)]


# ============================================================
# 主流程（Demo 入口）
# ============================================================

def main():
    """
    Demo 主函数。

    执行流程：
        1) KeyGen：生成一对公钥/私钥
        2) Encrypt：随机明文加密并注入错误
        3) Decrypt：使用私钥解密
        4) 对比明文，验证是否成功
    """

    # --------------------------------------------------------
    # 1) 参数设置（Demo 级别）
    # --------------------------------------------------------
    # L  : 分块数（总码长 n = 15 * L）
    # t0 : 每个 BCH 子块允许的最大错误数
    #
    # 这里选用的是“作业中最典型的一组参数”
    # - L=10  → 总码长 150
    # - t0=2  → BCH(15,7) 的纠错上限
    #
    # Demo 的目标不是比较参数，而是验证流程，
    # 因此参数固定即可。
    # --------------------------------------------------------

    L = 10
    t0 = 2

    print("\n========== 分块 BCH McEliece：快速演示 ==========\n")
    print(f"分块数 L = {L}")
    print(f"每块最大注入错误数 t0 = {t0}\n")

    # --------------------------------------------------------
    # 2) KeyGen：生成密钥对
    # --------------------------------------------------------
    # keygen(L, t_errors) 会：
    #   - 构造分块 BCH 编码结构
    #   - 生成随机可逆矩阵 S
    #   - 生成（块内）置换 P
    #   - 封装成一个 keypair 对象 kp
    #
    # 在 Demo 中，我们只关心：
    #   - 是否能成功生成
    #   - 基本参数 n, k
    #   - 大致耗时
    # --------------------------------------------------------

    t_start = time.time()
    kp = keygen(L=L, t_errors=t0)
    t_keygen = time.time() - t_start

    # 从 keypair 中读取码参数
    n = kp.code.n   # 总码长
    k = kp.code.k   # 信息位长度

    # --------------------------------------------------------
    # 公钥 / 私钥大小估算
    # --------------------------------------------------------
    # 说明：
    # - 这是“课程作业级”的粗略估算
    # - 目的是给数量级直觉，而非精确存储格式
    #
    # 公钥：k x n 的二进制矩阵
    # 私钥：S（k×k）+ P（n）+ 码参数
    # --------------------------------------------------------

    pk_bits = k * n
    priv_bits = (k ** 2) * 2 + n

    print(f"[KeyGen] n={n}, k={k}")
    print(f"[KeyGen] 公钥大小 ≈ {pk_bits/8/1024:.2f} KB")
    print(f"[KeyGen] 私钥大小 ≈ {priv_bits/8/1024:.2f} KB")
    print(f"[KeyGen] 用时：{t_keygen:.6f} 秒\n")

    # --------------------------------------------------------
    # 3) Encrypt：随机明文加密
    # --------------------------------------------------------
    # encrypt(kp, msg) 会：
    #   - 使用公钥对 msg 编码
    #   - 在每个 15-bit 子块内注入 ≤ t0 个错误
    #   - 返回：
    #       cipher   : 密文向量
    #       t_total  : 本轮实际注入的错误总数
    # --------------------------------------------------------

    msg = _rand_bits(k)

    t_start = time.time()
    cipher, t_total = encrypt(kp, msg)
    t_enc = time.time() - t_start

    print(f"[Encrypt] 实际注入错误总数 t_total = {t_total}")
    print(f"[Encrypt] 用时：{t_enc:.6f} 秒\n")

    # --------------------------------------------------------
    # 4) Decrypt：私钥解密
    # --------------------------------------------------------
    # decrypt(kp, cipher) 会：
    #   - 逆置换
    #   - 分块 BCH 译码
    #   - 还原明文
    #
    # 在 Demo 中，我们只验证：
    #   - 是否能恢复出原始 msg
    # --------------------------------------------------------

    t_start = time.time()
    msg_hat = decrypt(kp, cipher)
    t_dec = time.time() - t_start

    ok = (msg_hat == msg)

    print(f"[Decrypt] 用时：{t_dec:.6f} 秒")
    print(f"[Decrypt] 解密成功：{ok}\n")

    # --------------------------------------------------------
    # 5) Demo 结论
    # --------------------------------------------------------
    # 若 ok=True，说明：
    #   - 错误模型与译码器匹配
    #   - KeyGen / Enc / Dec 三者逻辑自洽
    #
    # 若 ok=False，通常意味着：
    #   - 错误模型不满足“每块 ≤ t0”
    #   - 或译码器与置换结构不一致
    # --------------------------------------------------------

    if ok:
        print("【演示通过】系统功能正确：KeyGen / Encrypt / Decrypt 全流程一致。")
    else:
        print("【演示失败】请优先检查：")
        print("  - 是否使用了块内置换")
        print("  - 是否保证每个 BCH 子块错误数 ≤ t0")

    print("\n=================================================\n")


# ============================================================
# Python 程序入口
# ============================================================

if __name__ == "__main__":
    main()
